1. Installed golang programming language 1.15
    https://golang.org/doc/install

    Short paragraph about the language.

2. Installed Docker for Debian buster. (Docker version 20.10.2)

    a) Installation: https://docs.docker.com/engine/install/debian/
    b) sudo chown edimoulis /var/run/docker.sock

    ex. docker run hello-world

    Short paragraph about Docker containers.


RUN MINIO LOCALY (NO DOCKER)

1. make

2. Enter credentials
2.1 export MINIO_ROOT_USER=minio
2.2 export MINIO_ROOT_PASSWORD=minio123

3. ./minio server /mnt/data

MC CLIENT

1. Edit /home/edimoulis/.mc/config.json
2. # Listing the buckets: ./mc ls myminio


PYTHON CLIENT

1. pip3 install minio
2. file_uploader.py

ex/ python3 file_uploader.py /home/edimoulis/Master/Semester3/Security-of-Computer-Systems/Project/test.txt

CONNECT TO MINIO VIA TLS

Link: https://docs.min.io/docs/how-to-secure-access-to-minio-server-with-tls.html

ex. ./minio server /mnt/data --certs-dir=/home/edimoulis/.minio/certs

1. Generate a private key with RSA.
    
    openssl genrsa -out private.key 2048

2. Create a file named openssl.conf with the content below.
    Set IP.1 and/or DNS.1 to point to the correct IP/DNS addresses:

    example in: SSL_Self_Signed/openssl.conf

3. Run openssl
    
    openssl req -new -x509 -nodes -days 730 -key private.key -out public.crt -config openssl.conf

4. Copy the key and the certifcate to certs directory
    a. cp public.crt /home/edimoulis/.minio/certs/
    b. cp private.key /home/edimoulis/.minio/certs/


# AES256 Encryptiom
To encrypt/decrypt a .txt file: ex./  go run aes256_file_encrypt.go test.txt

# To expose Go function and cretaing C library to call in Python
go build -buildmode=c-shared -o libencrypt.so libencrypt.go



AWS CLIENT

1. Put an object:

aws s3api put-object \
  --no-verify-ssl \
  --endpoint-url https://localhost:9000 \
  --bucket photos --key aeskey \
  --sse-customer-algorithm AES256 \
  --sse-customer-key MzJieXRlc2xvbmdzZWNyZXRrZXltdXN0cHJvdmlkZWQ= \
  --sse-customer-key-md5 7PpPLAK26ONlVUGOWlusfg== \
  --body ~/Master/Semester3/Security-of-Computer-Systems/Project/key.dat

2. Get an object

aws s3api get-object \
  --no-verify-ssl \
  --endpoint-url https://localhost:9000 \
  --bucket photos \
  --key key.dat \
  --sse-customer-algorithm AES256 \
  --sse-customer-key MzJieXRlc2xvbmdzZWNyZXRrZXltdXN0cHJvdmlkZWQ= \
  --sse-customer-key-md5 7PpPLAK26ONlVUGOWlusfg== \
  key.dat


Key rotation

S3 clients can change the client-provided key of an existing object. Therefore an S3 client must perform a S3 COPY operation where the copy source and destination are equal. Further the COPY request headers must contain the current and the new client key:

    X-Amz-Server-Side-Encryption-Customer-Key: Base64 encoded new key.
    X-Amz-Copy-Source-Server-Side-Encryption-Customer-Key: Base64 encoded current key.

Such a special COPY request is also known as S3 SSE-C key rotation



SSE-C: Server Side Encryption with Customer Key

The MinIO server will reject any SSE-C request made over an insecure (non-TLS) connection per the S3 specification. This means that SSE-C requires TLS / HTTPS, and an SSE-C request contains the encryption key.
If an SSE-C request is made over a non-TLS connection, the SSE-C encryption key must be treated as compromised.
Per the S3 specification, the content-md5 returned by an SSE-C PUT operation does not match the MD5 sum of the uploaded object.
The MinIO server uses a tamper-proof encryption scheme to encrypt objects and does not save the encryption key, which means you are responsible for managing encryption keys. If you lose the encryption key for an object, you will lose the ability to decrypt that object.

Secret Keys

The MinIO server uses an unique, randomly generated secret key per object also known as, Object Encryption Key (OEK). Neither the client-provided SSE-C key nor the KMS-managed key is directly used to en/decrypt an object. Instead, the OEK is stored as part of the object metadata next to the object in an encrypted form. To en/decrypt the OEK another secret key is needed also known as, Key Encryption Key (KEK).

The MinIO server runs a key-derivation algorithm to generate the KEK using a pseudo-random function (PRF):
KEK := PRF(EK, IV, context_values) where:

    EK: is the external key. In case of SSE-C this is the client-provided key. In case of SSE-S3 this is secret key generated by the KMS. For further details see SSE-C or SSE-S3.
    IV: is a randomly generated initialization vector. It is public and part of the object metadata.
    context_values: are values like the bucket and object name and other information which should be cryptographically bound to the KEK.

To summarize for any encrypted object there exists (at least) three different keys:

    OEK: A secret and unique key used to encrypted the object, stored in an encrypted form as part of the object metadata and only loaded to RAM in plaintext during en/decrypting the object.
    KEK: A secret and unique key used to en/decrypt the OEK and never stored anywhere. It is(re-)generated whenever en/decrypting an object using an external secret key and public parameters.
    EK: An external secret key - either the SSE-C client-provided key or a secret key generated by the KMS.


NOTES:

sse customer key: This header is used to transport the base 64 encoded byte string representation of the AES 256 key used in the server-side encryption process.
sse customer key md5: This header is used to transport the base64-encoded 128-bit MD5 digest of the encryption key according to RFC 1321. The object store uses this value to validate the key passes in the x-amz-server-side-encryption-customer-key has not been corrupted during transport and encoding process.
                      The digest must be calculated on the key BEFORE the key is base 64 encoded.


INTERCEPTING HHTP REQUESTS - TCPDUMP

Redirect tcpdump output of file upload via TLS to tls_dump.txt.
-X : Show the packetâ€™s contents in both hex and ASCII.

sudo tcpdump -i any port 9000 -X >> tls_dump.txt

Verified that via TLS the file contents are encrypted but with non-TLS communication a curious attacker may observe the file content if no previous encryption was applied